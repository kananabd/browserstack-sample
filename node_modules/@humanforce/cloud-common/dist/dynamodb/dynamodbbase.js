"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DynamoDbBase = void 0;
const client_dynamodb_1 = require("@aws-sdk/client-dynamodb");
const util_retry_1 = require("@smithy/util-retry");
const logger_1 = require("../utils/logger");
const helpers_1 = require("../utils/helpers");
const batchbehavior_1 = require("../helpers/batchbehavior");
const lib_dynamodb_1 = require("@aws-sdk/lib-dynamodb");
/**
 * Base methods to work with the DynamoDB
 *
 * @export
 * @class DBConnection
 */
class DynamoDbBase {
    constructor() {
        this.tablePrefix = process.env.LAMBDA_ALIAS;
        const options = {
            region: process.env.AWS_REGION,
            retryStrategy: new util_retry_1.ConfiguredRetryStrategy(10, this.customBackoff)
        };
        this.ddb = new client_dynamodb_1.DynamoDBClient(options);
        this.docClient = lib_dynamodb_1.DynamoDBDocumentClient.from(this.ddb, {
            marshallOptions: {
                // Whether to remove undefined values while marshalling.
                removeUndefinedValues: true,
                // Whether to convert typeof object to map attribute.
                convertClassInstanceToMap: true
            }
        });
    }
    /**
     * Returns exact one item from DB.
     *
     * @param {string} tableName - Name of DynamoDB table (with no prefix).
     * @param {string} keyName - name of hash key in the table.
     * @param {string} keyValue - value of the hash key.
     * @param {string} sortKeyName - name of the sort key.
     * @param {string} sortKeyValue - value of the sort key.
     * @param {boolean} useTablePrefix - table prefix flag.
     * @returns {Promise<GetCommandOutput>}
     */
    async getItem(tableName, keyName, keyValue, sortKeyName, sortKeyValue, useTablePrefix = true) {
        const item = {
            Key: {},
            TableName: (useTablePrefix ? `${this.tablePrefix}_` : "") + tableName
        };
        item.Key[keyName] = keyValue;
        // add sort key if required
        if (sortKeyName && sortKeyValue) {
            item.Key[sortKeyName] = sortKeyValue;
        }
        const command = new lib_dynamodb_1.GetCommand(item);
        logger_1.Logger.traceMessage("Item to get: %s", JSON.stringify(item, null, 2));
        return await this.docClient.send(command);
    }
    /**
     * Returns items from DB.
     * @param {string} tableName - Name of DynamoDB table (with no prefix).
     * @param {string} keyName - name of hash key in the table.
     * @param {string[]} keyValues - values of the hash key.
     * @param {boolean} useTablePrefix - table prefix flag.
     * @returns {Promise<Record<string, any>>[]>}
     */
    async getItems(tableName, keyName, keyValues, useTablePrefix = true, useBackoff = true) {
        const t1 = process.hrtime();
        if (keyValues.length === 0) {
            return this.getAllItems(tableName, useTablePrefix);
        }
        let res = [];
        // A single operation can retrieve up to 16 MB of data, which can contain as many as 100 items
        // @see https://docs.aws.amazon.com/amazondynamodb/latest/APIReference/API_BatchGetItem.html
        const batchBehavior = new batchbehavior_1.BatchBehavior(100, async (keys) => {
            const batch = {
                RequestItems: {
                    [(useTablePrefix ? `${this.tablePrefix}_` : "") + tableName]: {
                        Keys: keys
                    }
                }
            };
            const command = new lib_dynamodb_1.BatchGetCommand(batch);
            let batchRes = await this.docClient.send(command);
            if (!batchRes.Responses) {
                return;
            }
            res = res.concat(batchRes.Responses[Object.keys(batchRes.Responses)[0]]);
            let retryCount = 0;
            while (batchRes.UnprocessedKeys && Object.keys(batchRes.UnprocessedKeys).length) {
                logger_1.Logger.traceMessage("Read capacity was exhausted %d time(s) in %s", retryCount, "getItems");
                if (useBackoff) {
                    // give it some time to recover capacity units
                    await this.waitForTableCapacity(retryCount++);
                }
                batchRes = await this.docClient.send(new lib_dynamodb_1.BatchGetCommand({ RequestItems: batchRes.UnprocessedKeys }));
                if (batchRes.Responses) {
                    res = res.concat(batchRes.Responses[Object.keys(batchRes.Responses)[0]]);
                }
            }
        });
        for (let i = 0; i < keyValues.length; i++) {
            await batchBehavior.push({
                [keyName]: keyValues[i]
            });
        }
        await batchBehavior.flush();
        const t2 = process.hrtime(t1);
        logger_1.Logger.traceMessage("Batch get from %s, %d records, %ds %sms", tableName, res.length, t2[0], (t2[1] / 1000000).toFixed(2));
        return res;
    }
    /**
     * Returns items from DB.
     * @param {string} tableName - Name of DynamoDB table (with no prefix).
     * @param {string} indexName - name of the index in the table.
     * @param {string} keyExpression - query key expression.
     * @param {Record<string, any>} expressionValues - query expression attribute value.
     * @param {Record<string, string>} expressionAttributeNameMap - query expression attribute name.
     * @param {boolean} useTablePrefix - table prefix flag.
     * @returns {Promise<Record<string, any>[]>}
     */
    async getItemsByQuery(tableName, indexName, keyExpression, expressionValues, expressionAttributeNameMap, useTablePrefix = true, useBackoff = true, scanIndexForward = true) {
        const input = {
            TableName: (useTablePrefix ? `${this.tablePrefix}_` : "") + tableName,
            IndexName: indexName,
            KeyConditionExpression: keyExpression,
            ExpressionAttributeValues: expressionValues,
            ExpressionAttributeNames: expressionAttributeNameMap, // it used in cases when we use a reserved keyword in the keyExpression
            ScanIndexForward: scanIndexForward
        };
        let command = new lib_dynamodb_1.QueryCommand(input);
        let queryRes = await this.docClient.send(command);
        let itemList = queryRes.Items || [];
        let retryCount = 0;
        while (queryRes.LastEvaluatedKey) {
            logger_1.Logger.traceMessage("Read capacity was exhausted %d time(s) in %s", retryCount, "getAllItems");
            if (useBackoff) {
                // give it some time to recover capacity units
                await this.waitForTableCapacity(retryCount++);
            }
            input.ExclusiveStartKey = queryRes.LastEvaluatedKey;
            command = new lib_dynamodb_1.QueryCommand(input);
            queryRes = await this.docClient.send(command);
            if (queryRes.Items) {
                itemList = itemList.concat(queryRes.Items);
            }
        }
        return itemList;
    }
    /**
     * Returns all items from DB.
     * @param tableName - Name of DynamoDB table (with no prefix).
     * @param {boolean} useTablePrefix - table prefix flag.
     * @param {boolean} useBackoff - give it some time to recover capacity units
     * @param {ScanInput} scanInput - allow to scan table with parameters
     * @returns {<Record<string, any>[]>}
     */
    async getAllItems(tableName, useTablePrefix = true, useBackoff = true, scanInput) {
        let scanRes, itemList;
        const input = {
            ...scanInput,
            TableName: (useTablePrefix ? `${this.tablePrefix}_` : "") + tableName
        };
        let command = new lib_dynamodb_1.ScanCommand(input);
        scanRes = await this.docClient.send(command);
        itemList = scanRes.Items || [];
        let retryCount = 0;
        while (scanRes.LastEvaluatedKey) {
            logger_1.Logger.traceMessage("Read capacity was exhausted %d time(s) in %s", retryCount, "getAllItems");
            if (useBackoff) {
                // give it some time to recover capacity units
                await this.waitForTableCapacity(retryCount++);
            }
            input.ExclusiveStartKey = scanRes.LastEvaluatedKey;
            command = new lib_dynamodb_1.ScanCommand(input);
            scanRes = await this.docClient.send(command);
            if (scanRes.Items) {
                itemList = itemList.concat(scanRes.Items);
            }
        }
        return itemList;
    }
    /**
     * Insert item into DB.
     *
     * @param {string} tableName - Name of DynamoDB table (with no prefix).
     * @param {*} row - schemaless representation of data
     * @param {string} keyName - name of hash key in the table.
     * @param {string} keyValue - value of the hash key.
     * @param {string} sortKeyName - name of the sort key.
     * @param {string} sortKeyValue - value of the sort key.
     * @param {boolean} useTablePrefix - table prefix flag.
     * @returns {Promise<PutCommandOutput>} - a promised object to insert data into DB
     */
    putItem(tableName, row, keyName, keyValue, sortKeyName, sortKeyValue, useTablePrefix = true) {
        const putItemInput = {
            TableName: (useTablePrefix ? `${this.tablePrefix}_` : "") + tableName,
            Item: row
        };
        if (keyName) {
            putItemInput.Item[keyName] = keyValue;
        }
        if (sortKeyName) {
            putItemInput.Item[sortKeyName] = sortKeyValue;
        }
        const command = new lib_dynamodb_1.PutCommand(putItemInput);
        return this.docClient.send(command);
    }
    /**
     * Update item.
     *
     * @param tableName Name of DynamoDB table (with no prefix).
     * @param key Key of the entity.
     * @param updateExpression update expression.
     * @param attrValues expression attribute value map.
     * @param conditionExp condition expression.
     * @param attrNames expression attribute name map.
     * @param {boolean} useTablePrefix - table prefix flag.
     */
    async updateItem(tableName, key, updateExpression, attrValues, conditionExp, attrNames, useTablePrefix = true) {
        const putItemInput = {
            TableName: (useTablePrefix ? `${this.tablePrefix}_` : "") + tableName,
            Key: key,
            UpdateExpression: updateExpression,
            ExpressionAttributeValues: attrValues,
            ConditionExpression: conditionExp,
            ExpressionAttributeNames: attrNames
        };
        const command = new lib_dynamodb_1.UpdateCommand(putItemInput);
        await this.docClient.send(command);
    }
    /**
     * Deletes item from DB.
     *
     * @param {string} tableName - Name of DynamoDB table (with no prefix).
     * @param {string} keyName - name of hash key in the table.
     * @param {string} keyValue - value of the hash key.
     * @param {string} sortKeyName - name of the sort key.
     * @param {string} sortKeyValue - value of the sort key.
     * @param {boolean} useTablePrefix - table prefix flag.
     * @returns {Promise<DeleteCommandOutput>} - a promised object to insert data into DB
     */
    deleteItem(tableName, keyName, keyValue, sortKeyName, sortKeyValue, useTablePrefix = true) {
        const item = {
            TableName: (useTablePrefix ? `${this.tablePrefix}_` : "") + tableName,
            Key: {}
        };
        item.Key[keyName] = keyValue;
        // add sort key if required
        if (sortKeyName && sortKeyValue) {
            item.Key[sortKeyName] = sortKeyValue;
        }
        const command = new lib_dynamodb_1.DeleteCommand(item);
        logger_1.Logger.traceMessage("Item to delete %s", JSON.stringify(item, null, 2));
        return this.docClient.send(command);
    }
    /**
     * Process one batch from and adds (or updates) data in DB
     *
     * @private
     * @param {BatchWriteItemInput} batch
     * @returns {Promise<void>}
     */
    async batchInsert(batch, useBackoff = true) {
        const t1 = process.hrtime();
        let batchRes;
        let command = new client_dynamodb_1.BatchWriteItemCommand(batch);
        batchRes = await this.docClient.send(command);
        // Add users until all of them added
        let retryCount = 0;
        while (batchRes.UnprocessedItems && Object.keys(batchRes.UnprocessedItems).length) {
            if (useBackoff) {
                // give it some time to recover capacity units (in exponential fashion)
                await this.waitForTableCapacity(retryCount++);
            }
            command = new client_dynamodb_1.BatchWriteItemCommand({
                RequestItems: batchRes.UnprocessedItems
            });
            batchRes = await this.docClient.send(command);
        }
        if (logger_1.Logger.isTraceMessage() && batch.RequestItems) {
            const tableName = Object.keys(batch.RequestItems)[0];
            const t2 = process.hrtime(t1);
            logger_1.Logger.traceMessage("Batch insert to %s, %d records, %ds %sms", tableName, batch.RequestItems[tableName].length, t2[0], (t2[1] / 1000000).toFixed(2));
        }
    }
    /**
     * Waits for capacity recovering based on the amount of time we are hitting the limit
     * see https://aws.amazon.com/blogs/architecture/exponential-backoff-and-jitter/ for details
     *
     * @private
     * @param {number} retryCount - number of collisions happened before. This value increases the overall delay for better AWS capacity handling
     * @returns void
     */
    waitForTableCapacity(retryCount) {
        return new Promise(resolve => {
            setTimeout(resolve, this.customBackoff(retryCount));
        });
    }
    customBackoff(retryCount) {
        const DELAY = 1000;
        const MAX_DELAY = 5000; // limit to 5 seconds as it is enough in most cases to recover enough capacity
        const delay = Math.pow(2, retryCount) * DELAY;
        const jitter = helpers_1.Helpers.getRandomNumber(0, delay);
        const timeToWait = jitter < MAX_DELAY ? jitter : MAX_DELAY;
        logger_1.Logger.traceMessage("Waiting to recover capacity for %d ms", timeToWait);
        return timeToWait;
    }
}
exports.DynamoDbBase = DynamoDbBase;
