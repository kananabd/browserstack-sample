"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Helpers = void 0;
class Helpers {
    /**
     * Generate random number within given range
     * @param {number} min - left border of the range
     * @param max - right border of the range
     */
    static getRandomNumber(min, max) {
        return Math.floor(Math.random() * (max - min + 1) + min);
    }
    /**
     * Generates a new random guid
     *
     * @static
     * @returns Random guid
     */
    static genGUID() {
        return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function (c) {
            const r = Math.random() * 16 | 0;
            const v = c === "x" ? r : (r & 0x3 | 0x8);
            return v.toString(16);
        });
    }
    /**
     * Returns the current date/time in epoch
     *
     * @static
     * @returns number - epoch time
     */
    static getCurrentEpochTime() {
        return Math.floor(+new Date() / 1000);
    }
    /**
     * Convert string to boolean
     * @param value input string
     */
    static convertToBoolean(value) {
        if (!value) {
            return false;
        }
        value = value.toLowerCase();
        return value === "true" || value === "1" || value === "on";
    }
    /**
     * Get ARN topic by name
     * @param name topic name
     * @param isEndpointATopic use lambda prefix or not. The topic name should include prefix (value of LAMBDA_ALIAS), but notification ARN shouldn't
     */
    static getTopicARNByName(name, isEndpointATopic) {
        if (!process.env.AWS_REGION || !process.env.ACCOUNT_ID) {
            throw new Error("No application platform available. Please check env variables.");
        }
        const baseARN = `arn:aws:sns:${process.env.AWS_REGION}:${process.env.ACCOUNT_ID}:`;
        if (process.env.LAMBDA_ALIAS && isEndpointATopic) {
            name = process.env.LAMBDA_ALIAS + "_" + name;
        }
        return baseARN + name;
    }
    /**
     * Check if email is valid
     * @param email email address
     */
    static isEmailValid(email) {
        return /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9-]+(?:\.[a-zA-Z0-9-]+)*$/.test(email);
    }
    /**
     * Trim all leading and trailing white spaces from string values of object
     * @param obj any object
     */
    static deepTrim(obj) {
        if (!obj) {
            return;
        }
        for (const prop in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, prop)) {
                const value = obj[prop];
                const type = typeof value;
                if (value !== null && (type === "string" || type === "object")) {
                    if (type === "object") {
                        Helpers.deepTrim(obj[prop]);
                    }
                    else {
                        obj[prop] = obj[prop].trim();
                    }
                }
            }
        }
    }
    static base64UrlEncode(source) {
        return Buffer.from(source).toString("base64")
            .replace(/\+/g, "-")
            .replace(/\//g, "_")
            .replace(/=+$/, "");
    }
    static base64UrlDecode(source) {
        return this.base64UrlDecodeToBuffer(source).toString("utf-8");
    }
    static base64UrlDecodeToBuffer(source) {
        const m = source.length % 4;
        return Buffer.from(source
            .replace(/-/g, "+")
            .replace(/_/g, "/")
            .padEnd(source.length + (m === 0 ? 0 : 4 - m), "="), "base64");
    }
}
exports.Helpers = Helpers;
