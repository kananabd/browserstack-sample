"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.FeatureFlagRepository = void 0;
const invalidateapigatewayinstancecache_1 = require("../decorators/invalidateapigatewayinstancecache");
const dynamodbbase_1 = require("./dynamodbbase");
const instancerepo_1 = require("./instancerepo");
const featureflagmodel_1 = require("./models/featureflagmodel");
class FeatureFlagRepository extends dynamodbbase_1.DynamoDbBase {
    constructor() {
        super(...arguments);
        this.systemInstanceId = "system";
    }
    /**
     * Returns feature flags by given identifier
     * @param {string[]} instanceIds - an unique feature flags identifiers
     * @returns {Promise<FeatureFlag[]>} - promised object to get feature flags
     */
    async getFeatureFlags(instanceIds) {
        const result = [];
        const featureFlags = await this.getItems("FeatureFlag", "instanceId", instanceIds, false, false);
        if (featureFlags.length === 0) {
            return [];
        }
        for (const featureFlag of featureFlags) {
            result.push(featureflagmodel_1.FeatureFlag.bind(featureFlag));
        }
        return result;
    }
    async getMergedFlags(instanceId) {
        const featureFlags = [];
        const dbFeatureFlags = await this.getFeatureFlags([this.systemInstanceId, instanceId]);
        if (dbFeatureFlags?.length) {
            const instanceFeatureFlags = dbFeatureFlags.find(ff => ff.instanceId === instanceId);
            if (instanceFeatureFlags && instanceFeatureFlags.flags?.length) {
                instanceFeatureFlags.flags.forEach(instanceFlag => {
                    featureFlags.push({
                        name: instanceFlag.name,
                        value: instanceFlag.value,
                        inherited: false
                    });
                });
            }
            const systemFeatureFlags = dbFeatureFlags.find(ff => ff.instanceId === this.systemInstanceId);
            if (systemFeatureFlags && systemFeatureFlags.flags?.length) {
                systemFeatureFlags.flags.forEach(systemFlag => {
                    if (!featureFlags.some(f => f.name.toLowerCase() === systemFlag.name.toLowerCase())) {
                        featureFlags.push({
                            name: systemFlag.name,
                            value: systemFlag.value,
                            inherited: true
                        });
                    }
                });
            }
        }
        return featureFlags;
    }
    /**
     * Updates the feature flags
     * @param featureFlag
     * @returns {Promise<void>}
     */
    async updateFeatureFlag(featureFlag) {
        const ff = {
            instanceId: featureFlag.instanceId
        };
        for (let i = 0; i < featureFlag.flags.length; i++) {
            const flag = featureFlag.flags[i];
            ff[flag.name] = flag.value;
        }
        await this.putItem("FeatureFlag", ff, undefined, undefined, undefined, undefined, false);
        const instance = featureFlag.instanceId ? await new instancerepo_1.InstanceRepository().getSystemInstance(featureFlag.instanceId) : undefined;
        if (instance) {
            await this.invalidateInstanceCache(instance);
        }
    }
    /**
     * Deletes the feature flags
     * @param instanceId
     * @returns {Promise<void>}
     */
    async deleteFeatureFlag(instanceId) {
        await this.deleteItem("FeatureFlag", "instanceId", instanceId, undefined, undefined, false);
        const instance = await new instancerepo_1.InstanceRepository().getSystemInstance(instanceId);
        if (instance) {
            await this.invalidateInstanceCache(instance);
        }
    }
    async invalidateInstanceCache(instance) {
        return true;
    }
}
exports.FeatureFlagRepository = FeatureFlagRepository;
__decorate([
    (0, invalidateapigatewayinstancecache_1.InvalidateAPIGatewayInstanceCache)()
    // We have to use async here because the delegate is asynchronous
], FeatureFlagRepository.prototype, "invalidateInstanceCache", null);
