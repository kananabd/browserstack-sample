"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.S3Service = void 0;
const client_s3_1 = require("@aws-sdk/client-s3");
const commonconstants_1 = require("../constants/commonconstants");
const awsservice_1 = require("./awsservice");
const s3_request_presigner_1 = require("@aws-sdk/s3-request-presigner");
/**
 * Service to work with AWS S3
 */
class S3Service extends awsservice_1.AWSService {
    constructor() {
        super(...arguments);
        this.csvHeaderBytesLimit = 1024 * 5;
        this._s3 = new client_s3_1.S3Client({ credentials: this.getAWSCredentials() });
    }
    async doesBucketExist(bucketName) {
        const headBucketRequest = {
            Bucket: bucketName
        };
        const command = new client_s3_1.HeadBucketCommand(headBucketRequest);
        try {
            await this._s3.send(command);
            return true;
        }
        catch (e) {
            if (e instanceof client_s3_1.S3ServiceException && e.$metadata.httpStatusCode === 404) {
                return false;
            }
            throw e;
        }
    }
    async assumeRole(roleArn) {
        await super.assumeRole(roleArn);
        this._s3 = new client_s3_1.S3Client({ credentials: this.getAWSCredentials() });
    }
    async getAllBuckets() {
        const command = new client_s3_1.ListBucketsCommand({});
        return await this._s3.send(command);
    }
    async createPrivateBucket(bucketName) {
        const createRequest = {
            Bucket: bucketName,
            ACL: "private"
        };
        const createCommand = new client_s3_1.CreateBucketCommand(createRequest);
        await this._s3.send(createCommand);
        const publicAccessBlockRequest = {
            Bucket: bucketName,
            PublicAccessBlockConfiguration: {
                BlockPublicAcls: true,
                IgnorePublicAcls: true,
                BlockPublicPolicy: true,
                RestrictPublicBuckets: true
            }
        };
        const putPublicAccessBlockCommand = new client_s3_1.PutPublicAccessBlockCommand(publicAccessBlockRequest);
        await this._s3.send(putPublicAccessBlockCommand);
        const taggingRequest = {
            Bucket: bucketName,
            Tagging: {
                TagSet: [
                    { Key: commonconstants_1.CommonConstants.AWSTag.key, Value: commonconstants_1.CommonConstants.AWSTag.value }
                ]
            }
        };
        const taggingCommand = new client_s3_1.PutBucketTaggingCommand(taggingRequest);
        await this._s3.send(taggingCommand);
    }
    async deleteBucket(bucketName) {
        const deleteBucketRequest = {
            Bucket: bucketName
        };
        const deleteBucketCommand = new client_s3_1.DeleteBucketCommand(deleteBucketRequest);
        await this._s3.send(deleteBucketCommand);
    }
    async createFolder(bucketName, key) {
        const folderRequest = {
            Bucket: bucketName,
            Key: key
        };
        const putObjectCommand = new client_s3_1.PutObjectCommand(folderRequest);
        return await this._s3.send(putObjectCommand);
    }
    async isBucketEmpty(bucketName) {
        const listRequest = {
            Bucket: bucketName
        };
        const listObjectsCommand = new client_s3_1.ListObjectsCommand(listRequest);
        const objects = await this._s3.send(listObjectsCommand);
        return objects?.Contents?.length === 0;
    }
    async deleteFolder(bucketName, key) {
        const listRequest = {
            Bucket: bucketName,
            Prefix: key
        };
        const listObjectsCommand = new client_s3_1.ListObjectsCommand(listRequest);
        const objects = await this._s3.send(listObjectsCommand);
        if (objects?.Contents?.length) {
            const deleteRequest = {
                Bucket: bucketName,
                Delete: { Objects: [] }
            };
            objects.Contents.forEach(content => {
                if (content.Key) {
                    deleteRequest?.Delete?.Objects?.push({ Key: content.Key });
                }
            });
            const deleteCommand = new client_s3_1.DeleteObjectsCommand(deleteRequest);
            await this._s3.send(deleteCommand);
        }
    }
    async getCSVFileHeaders(bucketName, fileName) {
        const params = {
            Bucket: bucketName,
            Key: fileName,
            Range: `bytes=0-${this.csvHeaderBytesLimit}`
        };
        const getObjectCommand = new client_s3_1.GetObjectCommand(params);
        let result = [];
        try {
            const response = await this._s3.send(getObjectCommand);
            const fileContent = await response.Body?.transformToString();
            if (fileContent && fileContent.length > 0) {
                let headerLine = fileContent.toString();
                const nlIndex = fileContent.search(/[\r\n]/g);
                if (nlIndex === -1) {
                    console.log(`${fileName}: header row is too long`);
                    return result;
                }
                headerLine = headerLine.substring(0, nlIndex);
                result = headerLine.split(",");
            }
        }
        catch (e) {
            if (e instanceof client_s3_1.S3ServiceException) {
                console.log(e, e.stack);
            }
            else {
                throw e;
            }
        }
        return result;
    }
    async getBucketFiles(bucketName, prefix) {
        const params = {
            Bucket: bucketName,
            Prefix: prefix,
            Delimiter: "/",
            StartAfter: prefix
        };
        const command = new client_s3_1.ListObjectsV2Command(params);
        try {
            const data = await this._s3.send(command);
            if (data.KeyCount) {
                return data.Contents.map(object => object.Key?.replace(prefix, "") ?? "");
            }
            else {
                console.log(`Bucket ${bucketName} is empty`);
                return [];
            }
        }
        catch (e) {
            return [];
        }
    }
    async getBucketFilesWithMetadata(bucketName, prefix) {
        const params = {
            Bucket: bucketName,
            Prefix: prefix,
            Delimiter: "/",
            StartAfter: prefix
        };
        const command = new client_s3_1.ListObjectsV2Command(params);
        try {
            const data = await this._s3.send(command);
            if (data.KeyCount) {
                return data.Contents.map((object) => ({
                    name: object.Key?.replace(prefix, "") ?? "",
                    lastModified: object.LastModified
                }));
            }
            else {
                console.log(`Bucket ${bucketName} is empty`);
                return [];
            }
        }
        catch (e) {
            console.log(e);
            return [];
        }
    }
    async getSignedUrl(fileName) {
        const s3Params = {
            Bucket: process.env.UPLOAD_BUCKET,
            Key: fileName,
            ContentType: "text/csv"
        };
        const command = new client_s3_1.PutObjectCommand(s3Params);
        return (0, s3_request_presigner_1.getSignedUrl)(this._s3, command, { expiresIn: 60 });
    }
    async getFileInfo(bucket, filePath) {
        const params = {
            Bucket: bucket,
            Key: filePath
        };
        const headObjectCommand = new client_s3_1.HeadObjectCommand(params);
        try {
            return await this._s3.send(headObjectCommand);
        }
        catch (ex) {
            if (ex instanceof client_s3_1.S3ServiceException) {
                if (ex.$metadata.httpStatusCode !== 404) {
                    if (ex.$metadata.httpStatusCode === 401) {
                        console.warn(`Access to the file '${filePath}' is forbidden`);
                    }
                    else {
                        console.error(ex);
                    }
                }
            }
            return undefined;
        }
    }
    async deleteFile(bucket, filePath) {
        const bucketParams = {
            Bucket: bucket,
            Key: filePath
        };
        const deleteObjectCommand = new client_s3_1.DeleteObjectCommand(bucketParams);
        try {
            await this._s3.send(deleteObjectCommand);
            return true;
        }
        catch {
            return false;
        }
    }
    // This probably should return the Readable object returned from AWS
    // For now this will just be compatibility focused
    async getFileData(bucketName, fileName) {
        const params = {
            Bucket: bucketName,
            Key: fileName
        };
        const getObjectCommand = new client_s3_1.GetObjectCommand(params);
        try {
            const response = await this._s3.send(getObjectCommand);
            if (!response.Body) {
                return {
                    data: Buffer.from([])
                };
            }
            const bodyAsByteArray = await response.Body.toArray();
            const body = Buffer.concat(bodyAsByteArray);
            return {
                data: body,
                metadata: response.Metadata
            };
        }
        catch (e) {
            console.log(e);
            return {
                data: Buffer.from([])
            };
        }
    }
    async getFileTags(bucketName, fileName) {
        const params = {
            Bucket: bucketName,
            Key: fileName
        };
        const getObjectTaggingCommand = new client_s3_1.GetObjectTaggingCommand(params);
        try {
            const response = await this._s3.send(getObjectTaggingCommand);
            const tags = response.TagSet ?? [];
            return tags.reduce((tags, tag) => {
                if (tag.Key && tag.Value) {
                    tags.push({
                        name: tag.Key,
                        value: tag.Value
                    });
                }
                return tags;
            }, []);
        }
        catch (ex) {
            if (ex instanceof client_s3_1.S3ServiceException) {
                if (ex.message === "NoSuchKey") {
                    return undefined;
                }
            }
            console.log(ex);
            throw ex;
        }
    }
}
exports.S3Service = S3Service;
